\chapter{Metriche}

In questo capitolo verranno illustrate delle tecniche per valutare un weighting model e dunque poterlo confrontare con gli altri.
\'E di necessaria importanza poterlo fare perché nel capitolo sull'ottimizzazione di BM25P dovremo avere un modo per eseguire
la cosidetta fase di \textit{model selection}. Dovremo cioè valutare se un modello con un iperparametro $\lambda$ è
migliore rispetto a un modello con un iperparametro $\lambda' \neq \lambda$.

Ma in generale per valutare le prestazioni di un motore di ricerca possiamo usare due unità di misura:

\begin{itemize}
	\item La \textbf{qualità}, intesa come l'effettività, cioè quanto il motore di ricerca
	è in grado di mostrare all'utente documenti che siano rilevanti con la query $q$.
	\item L'\textbf{efficienza}, cioè quanto tempo viene impiegato nel calcolo dei risultati, quindi in questo caso
	quanto tempo impiega la fase di retrieval.
\end{itemize}

L'obiettivo di questo tirocinio è stato quello di massimizzare la qualità di BM25P, pertanto
la seconda unità di misura non è rilevante, anche perché variando il valore di un iperparametro
non si hanno ripercussioni notevoli sull'efficienza, ma solo sulla qualità.

Per poter valutare l'effettività è necessario riprendere il concetto di rilevanza  che era stato
accennato nel capitolo 1. La rilevanza purtroppo è una misura che non è del tutto oggettiva,
poiché un utente potrebbe decidere che la query $q$ e il documento $d$ siano
in qualche modo collegati tra loro oppure no.

\begin{esempio}
	Sia $q$ la query \textit{``python"}. L'utente potrebbe intendere sia il linguaggio di programmazione Python
	che l'animale stesso. Dunque se questa query fosse sottomessa a un motore di ricerca
	esso potrebbe ritornare all'utente entrambi i risultati, che a seconda della necessità
	l'utente potrebbe valutarli come rilevanti oppure no.
\end{esempio}

Ciò che l'utente intende è chiamata \textit{Information Need}, cioè la richiesta di informazione
che si tenta di esprimere sottomettendo una query al sistema di ricerca.

La soggettività di questa valutazione è uno dei punti cruciali dell'Information Retrieval, per cui non esistono
metodi matematici per calcolarla, ed è necessario l'intervento di un essere umano.
Diamo dunque la definizione di rilevanza booleana:

\begin{definizione}\label{def:relb}
	La rilevanza booleana $\rel_B(d,q): \mathcal{D} \times \mathcal{Q} \rightarrow \mathbb{B}$
	è una funzione binaria che associa alla coppia query-documento un valore booleano
	true o false, in questo modo:
	\begin{itemize}
		\item		$\rel_B(d,q) = true$ se e solo se l'utente ritiene che il documento d è rilevante
							per la query $q$.
		\item $\rel_B(d,q) = false$ altrimenti.
	\end{itemize}
	
	Anche se ovvio, sottolineamo il fatto che $\rel_B(q,d)$ dipende unicamente dalla query q e
	dal documento $d$. In altri contesti questo concetto può esser chiamato anche con il nome
	di \textit{ground truth} oppure \textit{gold standard}.
\end{definizione}

Il valore di tale funzione deve sempre esser calcolato da un essere umano, poiché
deve essere, come da definizione, deve rappresentare una verità soggettiva.

Ma ciò potrebbe sembrare però un po' limitante, poiché quando si parla di scoring,
$\sco(q,d)$ restituisce valori continui in $\mathbb{R}$ e dunque come può
approssimare $\rel_B$?
La risposta sta nel fatto che un ranker $\mathcal{R}$ si limita ad ordinare i documenti utilizzando come peso
il valore attribuito al documento dalla funzione $\sco$. Pertanto se ipotizzassimo di prendere
i primi $k$ elementi dalla lista $\mathcal{L}$, restituita dal motore di ricerca, potremo affermare che:

\begin{itemize}
	\item Se $d \in \mathcal{L}$  allora $\rel_{\mathcal{R}}(d, q) = true$
	\item Se $d \notin \mathcal{L}$ allora $\rel_{\mathcal{R}}(d,q) = false$
\end{itemize}

Attraverso questa definizione siamo in grado dunque di definire le modalità di valutazione di
un motore di ricerca, poiché possiamo paragonare i risultati di $\rel_B$ con quelli di $\rel_{\mathcal{R}}$,
ottenendo dunque un meccanismo di comparazione tra i risultati attesi e i risultati calcolati.

\subsection{Il principio PRP}

Introduciamo in questo paragrafo il \textit{Probability Ranking Principle}, ovvero un risultato
teorico che ci consente di avere una base matematica per valutare l'ottimalità di un ranker.
Tale principio afferma che:

\begin{definizione}\label{def:prp}
	Se per ogni query $q \in \mathcal{Q}$ il sistema ordina i documenti della collezione $\mathcal{D}$ in
	senso decrescente rispetto alla probabilità di rilevanza, allora l'effettività complessiva del sistema
	è la migliore ottenibile con i dati a disposizione.
\end{definizione}

Questo principio rappresenta l'unico metodo formale per verificare l'effettività di un sistema
di ricerca, poichè migliore è la stima che possiamo calcolare della rilevanza, migliori sono
le prestazioni.
Per completezza della trattazione dell'argomento diamo
una illustrazione di come dimostrare questo principio.

\begin{proof}
	Iniziamo la dimostrazione procedendo per punti:
	\begin{itemize}
		\item Sia $\mathcal{R}$ un ranker
		\item Siano $\mathcal{Q}$ e $\mathcal{D}$ gli insiemi delle query e dei documenti
		\item In questo contesto, sia $\rel_\mathcal{R}$ una variabile con natura aleatoria
		\item $\forall{q \in \mathcal{Q}, d \in \mathcal{D}}$ sia $P(\rel_B = r  | D = d, Q = q )$
		la probabilità che il documento $d$ sia rilevante per $q$.
		\item Sia $\mathcal{L}$  la lista ordinata dei documenti ritornati dal motore di ricerca, di lunghezza arbitraria
		$k$.
	\end{itemize}

Il valore atteso della rilevanza possiamo calcolarlo come:
\begin{align*}
& \mathbb{E}\left[\rel_B\right] = \sum_{i=1}^{k}{
	1 \cdot P(\rel_B = true  | D = d_i, Q = q ) + \cancelto{0}{0 \cdot  P(\rel_B = false  | D = d_i, Q = q )}
} \\
& \mathbb{E}\left[\rel_B\right] = \sum_{i=1}^{k}{P(\rel_B = true  | D = d_i, Q = q )}
\end{align*}

Ciò che vogliamo dimostrare è che per ogni valore di $k>0$, il valore atteso è massimo quando i documenti
sono ordinati in senso decrescente.
Procediamo dunque per assurdo ipotizzando esista un valore $\tilde{k}$ tale che $\mathbb{E}[\rel_B]$ sia
massimo anche se i documenti non sono ordinati in tal modo.
Si verifica dunque che esiste almeno un documento $d_l$ che non viene inserito in $\mathcal{L}$ nell'ordinamento
decrescente e inoltre ciò impone che un altro documento $d_m$ non venga inserito nell'ultima posizione della lista.
Abbiamo quindi che:
$$
P(\rel_B = r | D = d_l, Q=q)  < P(\rel_B = r| D = d_m, Q = q)
$$

e dunque:

\begin{align*}
& \mathbb{E}\left[\rel_B\right]_{\tilde{k}} = \sum_{i=1}^{\tilde{k}}{P(\rel_B = true | D = d_i, Q = q)} \\
	& \mathbb{E}[\rel_B]_{\tilde{k}} \Big|_{d_{\tilde{k}} = d_{l}} < \mathbb{E}[\rel_B]_{\tilde{k}} \Big|_{d_{\tilde{k}} = d_{m}}
\end{align*}

Ciò però è assurdo, perché per ipotesi $\mathbb{E}\left[\rel_B\right]_{\tilde{k}}$ sostituendo $d_{\tilde{k}}$ con $d_l$ doveva
essere massimo.
\end{proof}

\section{Recall e Precision}

Adesso che abbiamo raccolto tutte le informazioni necessarie possiamo definire
le unità di misura per la qualità di un motore di ricerca.
Le misure più semplici sono adottate attualmente sono  la recall e la precision.

\begin{definizione}\label{def:recall}
	La recall, indicata con il simbolo $\re$ è definita come il rapporto tra il numero di documenti
	messi in lista da $\mathcal{R}$, per cui $\rel_B(d,q) = true$,
	e il numero di elementi totali giudicati rilevanti.
	In simboli si ha:
	
	$$
	\re = P(d \in \mathcal{L} | \rel_B(d,q) = true) = \frac{
	\#\left\{ d \in \mathcal{L} | \rel_B(d,q) = true\right\}
}{
	\#\left\{ d \in \mathcal{D} | \rel_B(d,q) = true\right\}
}
	$$
\end{definizione}

\begin{definizione}\label{def:precision}
	La precision, indicata con il simbolo $\preci$ è uguale alla recall
	ma con la differenza che il rapporto non ha come denominatore tutti i documenti
	rilevanti, ma solo quelli in lista.
	
	$$
	\re = P(d \in \mathcal{L} | \rel_B(d,q) = true) = \frac{
		\#\left\{ d \in \mathcal{L} | \rel_B(d,q) = true\right\}
	}{
	\left|\mathcal{L}\right|
	}
	$$
\end{definizione}

Un modo per calcolare $\re$ e $\preci$ è quello di creare una sorta di confusion
matrix, nel seguente modo:

